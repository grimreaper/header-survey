#! /usr/bin/env python

# This script determines which subset of the following list of "common"
# header files (many are standard, some are not) are present on your
# operating system.  It does not attempt to distinguish between headers
# provided by the "core" operating system and headers provided by add-on
# packages, as this would require detailed understanding of the package
# management facilities.  If you wish, edit headers you know to be provided
# by optional packages out of the results.
#
# Takes one argument, the name of the compiler to use for tests.
# If no argument is provided, defaults to "cc".
#
# The list is generated by compute-common-headers.py.

import os
import shutil
import subprocess
import sys
import tempfile

common_header_files="""
aio.h
ar.h
assert.h
complex.h
cpio.h
ctype.h
dirent.h
dlfcn.h
elf.h
err.h
errno.h
fcntl.h
fenv.h
float.h
fmtmsg.h
fnmatch.h
ftw.h
getopt.h
glob.h
grp.h
iconv.h
ifaddrs.h
inttypes.h
iso646.h
langinfo.h
libgen.h
limits.h
link.h
locale.h
malloc.h
math.h
memory.h
monetary.h
mqueue.h
ndbm.h
netdb.h
nl_types.h
omp.h
paths.h
poll.h
pthread.h
pwd.h
regex.h
resolv.h
sched.h
search.h
semaphore.h
setjmp.h
sgtty.h
signal.h
spawn.h
stdarg.h
stdbool.h
stddef.h
stdint.h
stdio.h
stdlib.h
string.h
strings.h
stropts.h
sysexits.h
syslog.h
tar.h
termios.h
tgmath.h
thread_db.h
time.h
trace.h
ucontext.h
ulimit.h
unistd.h
utime.h
utmp.h
utmpx.h
varargs.h
wchar.h
wctype.h
wordexp.h
arpa/ftp.h
arpa/inet.h
arpa/nameser.h
arpa/nameser_compat.h
arpa/telnet.h
arpa/tftp.h
net/if.h
net/if_arp.h
net/ppp_defs.h
net/route.h
netinet/icmp6.h
netinet/if_ether.h
netinet/igmp.h
netinet/in.h
netinet/in_systm.h
netinet/ip.h
netinet/ip6.h
netinet/ip_icmp.h
netinet/tcp.h
netinet/udp.h
protocols/routed.h
protocols/rwhod.h
protocols/timed.h
rpc/auth.h
rpc/auth_des.h
rpc/auth_unix.h
rpc/clnt.h
rpc/des_crypt.h
rpc/key_prot.h
rpc/pmap_clnt.h
rpc/pmap_prot.h
rpc/pmap_rmt.h
rpc/rpc.h
rpc/rpc_msg.h
rpc/svc.h
rpc/svc_auth.h
rpc/types.h
rpc/xdr.h
rpcsvc/bootparam_prot.h
rpcsvc/mount.h
rpcsvc/nfs_prot.h
rpcsvc/nis.h
rpcsvc/nislib.h
rpcsvc/nlm_prot.h
rpcsvc/rex.h
rpcsvc/rquota.h
rpcsvc/rstat.h
rpcsvc/sm_inter.h
rpcsvc/spray.h
rpcsvc/yp_prot.h
rpcsvc/ypclnt.h
rpcsvc/yppasswd.h
sys/acct.h
sys/errno.h
sys/fcntl.h
sys/file.h
sys/ioctl.h
sys/ipc.h
sys/mman.h
sys/mount.h
sys/msg.h
sys/mtio.h
sys/param.h
sys/poll.h
sys/procfs.h
sys/queue.h
sys/reboot.h
sys/resource.h
sys/select.h
sys/sem.h
sys/shm.h
sys/signal.h
sys/socket.h
sys/socketvar.h
sys/stat.h
sys/statvfs.h
sys/syscall.h
sys/syslog.h
sys/termios.h
sys/time.h
sys/timeb.h
sys/times.h
sys/timex.h
sys/types.h
sys/ucontext.h
sys/uio.h
sys/un.h
sys/unistd.h
sys/user.h
sys/utsname.h
sys/wait.h
""".split()

# We detect header files by #including them. On some systems, some header
# files require you to include other headers first.  This is a table of
# all known situations where that's the case.

prerequisites = {
    # from OSX 10.6
    "net/if.h"           : ["sys/socket.h"],
    "netinet/icmp6.h"    : ["netinet/in.h"],
    "netinet/igmp.h"     : ["netinet/in.h"],
    "netinet/ip6.h"      : ["netinet/in.h"],
    "netinet/ip_icmp.h"  : ["netinet/in.h", "netinet/in_systm.h",
                            "netinet/ip.h"],
    "protocols/routed.h" : ["sys/socket.h"],
    "protocols/timed.h"  : ["sys/param.h"],
    "rpc/auth.h"         : ["rpc/rpc.h"],
    "rpc/auth_unix.h"    : ["rpc/rpc.h"],
    "rpc/clnt.h"         : ["rpc/rpc.h"],
    "rpc/pmap_clnt.h"    : ["rpc/rpc.h"],
    "rpc/pmap_prot.h"    : ["rpc/rpc.h"],
    "rpc/pmap_rmt.h"     : ["rpc/rpc.h"],
    "rpc/rpc_msg.h"      : ["rpc/rpc.h"],
    "rpc/svc.h"          : ["rpc/rpc.h"],
    "rpc/svc_auth.h"     : ["rpc/rpc.h"],
    "rpc/xdr.h"          : ["rpc/rpc.h"],
    "rpcsvc/yp_prot.h"   : ["rpc/rpc.h"],
    "sys/acct.h"         : ["sys/types.h"],
    "sys/socketvar.h"    : ["sys/socket.h"]
}

def gensrc(wd, header):
    def include(f, h):
        f.write("#include <{}>\n".format(os.path.join(*h.split("/"))))

    src = os.path.join(wd, "htest.c")
    with open(src, "w") as f:
        for p in prerequisites.get(header, []):
            include(f, p)
        include(f, header)
        # End with a global definition, in case some compiler
        # doesn't like source files that define nothing.
        # The #undefs are probably unnecessary, but you never know.
        f.write("#undef int\n#undef main\n#undef void\n#undef return\n"
                "int main(void){return 0;}\n")
    return src

def invoke(wd, argv):
    msg = os.path.join(wd, "htest-out.txt")
    with open(os.devnull, "rb") as stdi:
        with open(msg, "w") as stdo:
            stdo.write("# {}\n".format(" ".join(argv)))
            stdo.flush()
            rc = subprocess.call(argv, stdin=stdi, stdout=stdo,
                                 stderr=subprocess.STDOUT)
            stdo.write("# exit {}\n".format(rc))
    return (rc, msg)

def probe_one(wd, cc, header):
    src = gensrc(wd, header)
    (rc, msg) = invoke(wd, [cc, "-c", src])
    if rc == 0:
        return True
    with open(msg, "rU") as f: errors = f.read()

    (rc, msg) = invoke(wd, [cc, "-E", src])
    if rc == 0:
        sys.stderr.write("# {} present but cannot be compiled:\n"
                         .format(header))
        for e in errors.split("\n"): sys.stderr.write("# {}\n".format(e))

    return False

def probe(compiler, headers):
    wd=None
    good = set(headers)
    try:
        wd = tempfile.mkdtemp()
        src = os.path.join(wd, "htest.c")
        msg = os.path.join(wd, "messages.txt")
        with open(src, "w") as f:
            for h in headers:
                if not probe_one(wd, compiler, h):
                    good.remove(h)
    finally:
        if wd is not None:
            shutil.rmtree(wd)

    return good

if __name__ == '__main__':
    compiler = "cc"
    if len(sys.argv) > 1:
        compiler = sys.argv[1]
    good_headers = probe(compiler, common_header_files)
    for h in sorted(good_headers, key=lambda x: (x.count("/"), x)):
        sys.stdout.write(h + "\n")
